--- openssl-1.0.0d/crypto/cryptlib.h	2010-01-26 16:55:32 +0300
+++ openssl-1.0.0d/crypto/cryptlib.h	2011-04-02 18:35:14 +0400
@@ -80,10 +80,23 @@
 #endif
 
 #ifndef OPENSSL_SYS_VMS
+#ifdef _WIN32_WINNT
+#define X509_CERT_AREA_T	""
+#define X509_CERT_DIR_T	"\\certs"
+#define X509_CERT_FILE_T	"\\cert.pem"
+#define X509_PRIVATE_DIR_T	"\\private"
+#define X509_CERT_AREA		OPENSSLDIR X509_CERT_AREA_T
+#define X509_CERT_DIR		OPENSSLDIR X509_CERT_DIR_T
+#define X509_CERT_FILE		OPENSSLDIR X509_CERT_FILE_T
+#define X509_PRIVATE_DIR	OPENSSLDIR X509_PRIVATE_DIR_T
+void OPENSSL_rootdir_setup();
+const char *OPENSSL_rootdir_get();
+#else
 #define X509_CERT_AREA		OPENSSLDIR
 #define X509_CERT_DIR		OPENSSLDIR "/certs"
 #define X509_CERT_FILE		OPENSSLDIR "/cert.pem"
 #define X509_PRIVATE_DIR	OPENSSLDIR "/private"
+#endif
 #else
 #define X509_CERT_AREA		"SSLROOT:[000000]"
 #define X509_CERT_DIR		"SSLCERTS:"
--- openssl-1.0.0d/crypto/cryptlib.c	2010-11-19 03:11:27 +0300
+++ openssl-1.0.0d/crypto/cryptlib.c	2011-04-02 19:59:59 +0400
@@ -705,6 +705,90 @@
 /* All we really need to do is remove the 'error' state when a thread
  * detaches */
 
+/* On 2000/XP it might not terminate the string. We cheat by making it
+ * a little bit longer and setting that extra byte to zero. Either way
+ * it'll come out zero-terminated.
+ */
+#if defined(_WIN32_WINNT)
+char OPENSSL_rootdir[MAX_PATH + 1] = {0};
+HINSTANCE g_hinstDLL = NULL;
+int g_hinstDLL_new = 1;
+
+const char *OPENSSL_rootdir_get ()
+{
+  return (const char *) OPENSSL_rootdir;
+}
+
+void OPENSSL_rootdir_setup()
+{
+  if (!g_hinstDLL_new || g_hinstDLL == NULL) return;
+
+  g_hinstDLL_new=0;
+  OPENSSL_rootdir[MAX_PATH] = '\0';
+  if (GetModuleFileNameA ((HMODULE) g_hinstDLL, OPENSSL_rootdir, MAX_PATH) == 0)
+  {
+    /* This is BAD. TODO: figure out what to do here.
+     * For now i will just make it a zero-length string.
+     */
+     OPENSSL_rootdir[0] = 0;
+  }
+  else
+  {
+    char *slash = NULL;
+    char *bslash = NULL;
+    char *use_slash = NULL;
+    slash = strrchr (OPENSSL_rootdir, '/');
+    bslash = strrchr (OPENSSL_rootdir, '\\');
+    use_slash = slash > bslash ? slash : bslash;
+    if (use_slash <= 0)
+    {
+      /* This is the same kind of badness as above */
+      OPENSSL_rootdir[0] = 0;
+    }
+    else
+    {
+      size_t len;
+      use_slash[1] = '\0';
+      len = strlen (OPENSSL_rootdir);
+      /* Now OPENSSL_rootdir contains full path to this module's directory,
+       * with trailing slash (or backslash).
+       */
+      /* Following code will not work with names that have more than one
+       * slash or backslash in a row. Hopefully, WinAPI won't give us anythig
+       * like that
+       */
+      if (len >= 4 && strnicmp (OPENSSL_rootdir[len - 4], "bin", 3) == 0 && (OPENSSL_rootdir[len - 1] == '/' || OPENSSL_rootdir[len - 1] == '\\'))
+      {
+      /* If we're in <foo>/bin/, look for stuff in <foo>/var/ssl/
+       */
+        OPENSSL_rootdir[len - 4] = '\0';
+        /* Now OPENSSL_rootdir contains full path to <foo>,
+         * with trailing slash (or backslash).
+         */
+        if (len - 4 + 8 < MAX_PATH - 1)
+          sprintf (&OPENSSL_rootdir[len - 4], "var\\ssl\\");
+        else
+          OPENSSL_rootdir[0] = '\0';
+      }
+      else
+      {
+       /* If we're in <baz>/, look for stuff in <baz>/var/ssl/
+        */
+        if (len + 8 < MAX_PATH - 1)
+          sprintf (&OPENSSL_rootdir[len], "var\\ssl\\");
+        else
+          OPENSSL_rootdir[0] = '\0';
+      }
+    }
+  }
+
+  /* Now OPENSSL_rootdir is the full path to .../ssl/ directory,
+   * with trailing slash or backslash.
+   * Or it's a zero-length string.
+   */
+}
+#endif
+
 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason,
 	     LPVOID lpvReserved)
 	{
@@ -714,6 +798,8 @@
 		OPENSSL_cpuid_setup();
 #if defined(_WIN32_WINNT)
 		{
+		g_hinstDLL = hinstDLL;
+                g_hinstDLL_new = 1;
 		IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)hinstDLL;
 		IMAGE_NT_HEADERS *nt_headers;
 
--- openssl-1.0.0d/crypto/x509/x509_def.c	1999-09-11 21:54:11 +0400
+++ openssl-1.0.0d/crypto/x509/x509_def.c	2011-04-02 20:19:28 +0400
@@ -61,6 +61,60 @@
 #include <openssl/crypto.h>
 #include <openssl/x509.h>
 
+char X509_get_default_private_dir_variable[MAX_PATH];
+char X509_get_default_cert_area_variable[MAX_PATH];
+char X509_get_default_cert_dir_variable[MAX_PATH];
+char X509_get_default_cert_file_variable[MAX_PATH];
+
+#if defined(_WIN32_WINNT)
+static int compose_name (char *storage, char *trail)
+{
+  const char *rootdir;
+  int r;
+  OPENSSL_rootdir_setup ();
+  rootdir = OPENSSL_rootdir_get ();
+  if (rootdir == NULL || strlen (rootdir) <= 0)
+    return 0;
+  if (strlen (trail > 0))
+    r = snprintf (storage, MAX_PATH - 1, "%s%s", rootdir, &trail[1]);
+  else
+    r = snprintf (storage, MAX_PATH - 1, "%s", rootdir);
+  if (r < 0)
+    return 0;
+  storage[MAX_PATH - 1] = 0;
+  if (strlen (trail) == 0)
+    storage[strlen (storage) - 1] = '\0';
+  return strlen (storage);
+}
+
+const char *X509_get_default_private_dir(void)
+{
+  if (!compose_name (X509_get_default_private_dir_variable, X509_PRIVATE_DIR_T))
+    return(X509_PRIVATE_DIR);
+  return X509_get_default_private_dir_variable;
+}
+	
+const char *X509_get_default_cert_area(void)
+{
+  if (!compose_name (X509_get_default_cert_area_variable, X509_CERT_AREA_T))
+    return(X509_CERT_AREA);
+  return X509_get_default_cert_area_variable;
+}
+
+const char *X509_get_default_cert_dir(void)
+{
+  if (!compose_name (X509_get_default_cert_dir_variable, X509_CERT_DIR_T))
+    return(X509_CERT_DIR);
+  return X509_get_default_cert_dir_variable;
+}
+
+const char *X509_get_default_cert_file(void)
+{ 
+  if (!compose_name (X509_get_default_cert_file_variable, X509_CERT_FILE_T))
+    return(X509_CERT_FILE);
+  return X509_get_default_cert_file_variable;
+}
+#else
 const char *X509_get_default_private_dir(void)
 	{ return(X509_PRIVATE_DIR); }
 	
@@ -72,6 +126,7 @@
 
 const char *X509_get_default_cert_file(void)
 	{ return(X509_CERT_FILE); }
+#endif
 
 const char *X509_get_default_cert_dir_env(void)
 	{ return(X509_CERT_DIR_EVP); }
